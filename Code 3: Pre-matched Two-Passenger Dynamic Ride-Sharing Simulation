# -*- coding: utf-8 -*-
"""
Pre-matched Two-Passenger Real-time Ride-Pooling with Batch Matching and Hard 293s Waiting Constraint
author: 鲍鸿庆

## Citation
Please cite the following paper if you use this code in your research:
Bao, H., Luo, X., Su, Q., & Wang, H. (2025). Optimizing last-mile public transit services by leveraging modular autonomous vehicles. Journal of Transportation Engineering, Part A: Systems, 151(8). https://doi.org/10.1061/JTEPBS.TEENG-8954
"""

import pandas as pd
import numpy as np
from scipy.sparse import load_npz
from scipy.sparse.csgraph import dijkstra
from dataclasses import dataclass
from typing import List, Optional, Tuple
import heapq
import gurobipy as gp
from gurobipy import GRB
import itertools
import time
from collections import defaultdict


# ============================= Configuration =============================
HUB_NODE_ID = 3099327955
AVERAGE_SPEED_KMH = 25
SPEED_MPS = AVERAGE_SPEED_KMH * 1000 / 3600
MAX_WAIT_TIME = 293
VEHICLE_CAPACITY = 2

ALPHA_PASSENGER_TIME = 1.0
BETA_LOADED_DISTANCE = 1.0
GAMMA_EMPTY_DISTANCE = 1.0
DELTA_IDLE_TIME = 0.5

NODE_FILE = "data/node.csv"
GRAPH_FILE = "data/csr_mat.npz"
DEMAND_FILE = "data/demand.csv"


# ============================= Data Structures =============================
@dataclass
class Passenger:
    id: int
    request_time: float
    destination_node: int
    destination_idx: int
    distance_from_hub: float
    return_distance: float
    dest_rank: int = -1
    pickup_time: float = 0.0
    dropoff_time: float = 0.0
    station_wait_time: float = 0.0
    group_id: Optional[int] = None

@dataclass
class PassengerGroup:
    group_id: int
    passengers: List[Passenger]
    total_distance: float = 0.0
    ready_time: float = 0.0

@dataclass
class Vehicle:
    id: int
    available_time: float
    total_hub_wait_time: float = 0.0
    trips: int = 0

    def __lt__(self, other):
        return (self.available_time, self.id) < (other.available_time, other.id)

@dataclass
class Trip:
    vehicle_id: int
    group: PassengerGroup
    departure_time: float
    return_time: float
    total_loaded_distance: float
    total_empty_distance: float
    hub_wait_time: float


# ============================= Global Variables =============================
hub_idx: int = None
dist_from_hub_all: np.ndarray = None
dist_to_hub_all: np.ndarray = None
dist_matrix: Optional[np.ndarray] = None
dest_rank_map: dict = {}
csr_mat = None
_group_id_counter = 0


def next_group_id() -> int:
    global _group_id_counter
    _group_id_counter += 1
    return _group_id_counter


# ============================= Load Network and Precompute Distances =============================
def load_network_and_precompute():
    global hub_idx, dist_from_hub_all, dist_to_hub_all, csr_mat, dist_matrix, dest_rank_map

    node_df = pd.read_csv(NODE_FILE)
    csr_mat = load_npz(GRAPH_FILE)
    node_id_to_idx = dict(zip(node_df['node_id'], node_df.index))
    hub_idx = node_id_to_idx.get(HUB_NODE_ID)

    if hub_idx is None:
        raise ValueError("Hub node not found")

    dist_from_hub_all = dijkstra(csr_mat, indices=[hub_idx], directed=True)[0]
    dist_to_hub_all = dijkstra(csr_mat.T, indices=[hub_idx], directed=True)[0]

    demand_df = pd.read_csv(DEMAND_FILE)
    valid_dest_idx = set()
    for node_id in demand_df['dropoff_node']:
        if node_id in node_id_to_idx:
            valid_dest_idx.add(node_id_to_idx[node_id])

    unique_dest_idx = sorted(valid_dest_idx)
    dest_rank_map.clear()
    for rank, idx in enumerate(unique_dest_idx):
        dest_rank_map[idx] = rank

    if 0 < len(unique_dest_idx) <= 6000:
        dist_matrix = dijkstra(csr_mat, indices=unique_dest_idx, directed=True)

    return demand_df, node_id_to_idx


# ============================= Cost Calculation =============================
def calculate_group_cost_ultra_fast(passengers: List[Passenger]) -> Tuple[float, float, float]:
    if not passengers:
        return np.inf, 0.0, 0.0

    sorted_p = sorted(passengers, key=lambda p: p.distance_from_hub)
    loaded_dist = 0.0

    for i, p in enumerate(sorted_p):
        if i == 0:
            seg = p.distance_from_hub
        else:
            prev_idx = sorted_p[i-1].destination_idx
            curr_idx = p.destination_idx
            if dist_matrix is not None:
                seg = dist_matrix[dest_rank_map[prev_idx], dest_rank_map[curr_idx]]
            else:
                seg = dijkstra(csr_mat, indices=prev_idx, directed=True)[0, curr_idx]
            if np.isinf(seg):
                return np.inf, 0.0, 0.0
        loaded_dist += seg

    empty_dist = sorted_p[-1].return_distance
    total_time = (loaded_dist + empty_dist) / SPEED_MPS
    return total_time, loaded_dist, empty_dist


# ============================= Batch Matching with Gurobi =============================
def optimize_passenger_matching(passengers: List[Passenger]):
    n = len(passengers)
    if n < 2:
        return []

    pairs = list(itertools.combinations(range(n), VEHICLE_CAPACITY))
    cost_dict = {}
    detail_dict = {}

    for pair in pairs:
        c, ld, ed = calculate_group_cost_ultra_fast([passengers[i] for i in pair])
        cost_dict[pair] = c if not np.isinf(c) else 1e8
        detail_dict[pair] = (ld, ed)

    m = gp.Model()
    m.Params.OutputFlag = 0
    m.Params.TimeLimit = 15
    x = m.addVars(pairs, vtype=GRB.BINARY)
    m.setObjective(gp.quicksum(cost_dict[p] * x[p] for p in pairs), GRB.MINIMIZE)

    for i in range(n):
        m.addConstr(gp.quicksum(x[p] for p in pairs if i in p) == 1)

    m.optimize()
    selected = []

    if m.status in (GRB.OPTIMAL, GRB.TIME_LIMIT):
        for pair, var in x.items():
            if var.X > 0.5:
                ld, ed = detail_dict[pair]
                selected.append(([passengers[i] for i in pair], ld, ed))

    return selected


# ============================= Batch Processing =============================
def match_passengers_in_batches(waiting: List[Passenger], batch_size: int, boarding_delay: float):
    if len(waiting) < batch_size:
        return [], waiting

    batch = waiting[:batch_size]
    remaining = waiting[batch_size:]
    trigger_time = max(p.request_time for p in batch) + boarding_delay

    for p in batch:
        p.pickup_time = trigger_time
        p.station_wait_time = trigger_time - p.request_time

    groups = optimize_passenger_matching(batch)
    result = []

    for pas, ld, ed in groups:
        group = PassengerGroup(
            group_id=next_group_id(),
            passengers=pas,
            total_distance=ld + ed,
            ready_time=trigger_time
        )
        for p in pas:
            p.group_id = group.group_id
        result.append((group, ld, ed))

    return result, remaining


# ============================= Main Simulation =============================
def simulate(max_vehicles: int, batch_size: int, boarding_delay: float = 0.0):
    global _group_id_counter
    _group_id_counter = 0

    demand_df, node_id_to_idx = load_network_and_precompute()
    passengers = []
    pid = 0

    for _, row in demand_df.iterrows():
        node_id = row['dropoff_node']
        if node_id not in node_id_to_idx:
            continue
        idx = node_id_to_idx[node_id]
        d_out = dist_from_hub_all[idx]
        d_back = dist_to_hub_all[idx]
        if np.isinf(d_out) or np.isinf(d_back):
            continue

        p = Passenger(
            id=pid,
            request_time=row['pickup_time'],
            destination_node=node_id,
            destination_idx=idx,
            distance_from_hub=d_out,
            return_distance=d_back,
            dest_rank=dest_rank_map.get(idx, -1)
        )
        passengers.append(p)
        pid += 1

    passengers.sort(key=lambda p: p.request_time)
    if not passengers:
        return 0, 0, 0, 0

    waiting = []
    matched_groups = []
    avail_heap = []
    vehicles = {}
    vehicle_counter = 0
    trips = []
    i = 0
    t = passengers[0].request_time

    while True:
        while i < len(passengers) and passengers[i].request_time <= t + 1e-6:
            waiting.append(passengers[i])
            i += 1

        if len(waiting) >= batch_size:
            new_groups, waiting = match_passengers_in_batches(waiting, batch_size, boarding_delay)
            matched_groups.extend(new_groups)

        elif waiting:
            timeout_ps = [p for p in waiting if t - p.request_time >= MAX_WAIT_TIME]
            if timeout_ps:
                timeout_ps.sort(key=lambda p: p.request_time)
                remaining = timeout_ps

                if len(timeout_ps) >= VEHICLE_CAPACITY:
                    n_pairs = (len(timeout_ps) // VEHICLE_CAPACITY) * VEHICLE_CAPACITY
                    batch = timeout_ps[:n_pairs]
                    waiting = [p for p in waiting if p not in batch]
                    new_groups, _ = match_passengers_in_batches(batch, len(batch), t)
                    matched_groups.extend(new_groups)
                    remaining = timeout_ps[n_pairs:]

                for p in remaining:
                    if p in waiting:
                        waiting.remove(p)
                        group = PassengerGroup(
                            group_id=next_group_id(),
                            passengers=[p],
                            total_distance=p.distance_from_hub + p.return_distance,
                            ready_time=p.request_time + MAX_WAIT_TIME
                        )
                        matched_groups.append((group, p.distance_from_hub, p.return_distance))

        to_remove = []
        for item in matched_groups:
            group, loaded, empty = item
            if group.ready_time > t + 1e-6:
                continue

            v = None
            while avail_heap and avail_heap[0][0] <= t + 1e-6:
                _, _, v = heapq.heappop(avail_heap)
                break
            if v is None and len(vehicles) < max_vehicles:
                vehicle_counter += 1
                v = Vehicle(vehicle_counter, t)
                vehicles[v.id] = v
            if v is None:
                continue

            dep_time = max(t, v.available_time, group.ready_time)
            for p in group.passengers:
                p.pickup_time = dep_time
                p.station_wait_time = dep_time - p.request_time

            cum_dist = 0.0
            prev_idx = hub_idx
            sorted_p = sorted(group.passengers, key=lambda x: x.distance_from_hub)
            for p in sorted_p:
                if prev_idx == hub_idx:
                    seg = p.distance_from_hub
                else:
                    r1 = dest_rank_map[prev_idx]
                    r2 = p.dest_rank
                    seg = dist_matrix[r1, r2] if dist_matrix is not None else \
                          dijkstra(csr_mat, indices=prev_idx, directed=True)[0, p.destination_idx]
                cum_dist += seg
                p.dropoff_time = dep_time + cum_dist / SPEED_MPS
                prev_idx = p.destination_idx

            return_time = dep_time + (loaded + empty) / SPEED_MPS
            hub_wait = sum(dep_time - p.pickup_time for p in group.passengers)

            trip = Trip(v.id, group, dep_time, return_time, loaded, empty, hub_wait)
            trips.append(trip)
            v.available_time = return_time
            v.trips += 1
            heapq.heappush(avail_heap, (return_time, v.id, v))
            to_remove.append(item)

        for item in to_remove:
            matched_groups.remove(item)

        candidates = []
        if i < len(passengers):
            candidates.append(passengers[i].request_time)
        if avail_heap:
            candidates.append(avail_heap[0][0])
        if matched_groups:
            candidates.append(min(g[0].ready_time for g in matched_groups))
        if waiting:
            candidates.append(min(p.request_time for p in waiting) + MAX_WAIT_TIME)

        future = [x for x in candidates if x > t + 1e-6]
        if not future:
            break
        t = min(future)

    served = [p for trip in trips for p in trip.group.passengers]
    if not served:
        return 0, 0, 0, 0

    total_passenger_time = sum(p.dropoff_time - p.request_time for p in served)
    total_loaded = sum(t.total_loaded_distance for t in trips)
    total_empty = sum(t.total_empty_distance for t in trips)
    total_wait = sum(p.station_wait_time for p in served)

    idle_time = 0.0
    trips_by_veh = defaultdict(list)
    for trip in trips:
        trips_by_veh[trip.vehicle_id].append(trip)
    for veh_trips in trips_by_veh.values():
        if len(veh_trips) >= 2:
            veh_trips.sort(key=lambda x: x.departure_time)
            for i in range(1, len(veh_trips)):
                gap = veh_trips[i].departure_time - veh_trips[i-1].return_time
                if gap > 0:
                    idle_time += gap

    total_cost = (ALPHA_PASSENGER_TIME * total_passenger_time +
                  BETA_LOADED_DISTANCE * total_loaded / SPEED_MPS +
                  GAMMA_EMPTY_DISTANCE * total_empty / SPEED_MPS +
                  DELTA_IDLE_TIME * idle_time)

    return (total_cost, len(vehicles), len(trips), len(served),
            total_passenger_time, total_wait, total_loaded, total_empty, idle_time)


# ============================= Execution =============================
if __name__ == "__main__":
    batch_sizes = [4, 6, 8, 10]
    fleet_sizes = list(range(20, 841, 20))
    results = []

    for bs in batch_sizes:
        for mv in fleet_sizes:
            cost, used, trips, served, ptime, wait, loaded, empty, idle = simulate(mv, bs, 0.0)

            occupancy = served / trips if trips > 0 else 0.0
            results.append({
                "max_fleet_size": mv,
                "vehicles_used": used,
                "total_cost_seconds": cost,
                "trips": trips,
                "passengers_served": served,
                "occupancy": round(occupancy, 3),
                "passenger_total_time_s": ptime,
                "waiting_time_s": wait,
                "loaded_distance_m": loaded,
                "empty_distance_m": empty,
                "idle_time_s": idle,
                "batch_size": bs
            })

    df = pd.DataFrame(results)
    df.to_csv("results.csv", index=False)
